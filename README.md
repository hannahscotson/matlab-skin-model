# Electronic Skin Model - Implemented in MATLAB

This repository contains the MATLAB code used to simulate and analyse the force response of an electronic skin model. This model is an expanded version of the model originally developed by [1] and was modified to reflect the real-life experiment developed in [2]. The code features functionality to generate simulated model force data, to perform classification for both simulated and experimental data, and to generate corresponding visualisations of data such as heatmaps and animation plots. Please find the file descriptions below as well as the references that were used to develop the model.

## Files

- **main.m**: Controls the overall process for generating model responses, adding noise, and performing classification on both model and experimental data. The script allows the user to choose between generating model responses (with and without noise), generating heatmaps, and performing classification tasks for both model and experimental data. It also includes functionality for generating temporal heatmaps and animations. The script has flags for specific tasks such as generating model responses for multiple trials or specific conditions, performing classification on model data, and visualising the results through heatmaps and animations.
- **addNoise.m**: Adds noise to the pre-generated model response, with noise levels randomly selected within a defined range. The noise is applied to nodes surrounding the predefined letter shapes, and the resulting data is stored in model_FSR_noisy for later use.
- **addTrials.m**: Duplicates the pre-generated model response to simulate multiple trials. This is used to test classifier performance without noise present in the data.
- **BoundaryNodes.m**: Applies fixed boundary conditions to nodes at the edges of each layer in the dynamic skin model. This function was created by the original authors of the referenced model and was not written as part of this project.
- **dataClassification.m**: Loads pre-processed FSR data that was collected in the experiment referenced in the report, extracts feature vectors from the trial with the highest FSR values, and classifies them using an SVM classifier. It splits the data into training and testing sets, standardises the data, and computes classification accuracy and the confusion matrix.
- **dataHeatmap.m**: Extracts the feature vector from the timestep with the highest average response in a given trial, reshapes it into a 16x16 matrix, and generates a heatmap of the FSR data. The heatmap visualises the response distribution at the best timestep.
- **findSurroundingNodes.m**: Identifies the surrounding nodes of each boundary node for predefined letter shapes. The function searches for the nodes that are part of triangles containing boundary nodes and stores them as surrounding nodes for each letter shape. It ensures that the surrounding nodes fall within a valid range (1 to 256) before storing them.
- **GaussF.m**: Generates a Gaussian force profile for each mass in the dynamic skin model based on the provided parameters. This function calculates the force values (Fx) and their second derivative (FxDyy) at each timestep, applying a Gaussian function with specified parameters. The resulting force profiles are used in the simulation. This function was created by the original authors of the referenced model and was not written as part of this project.
- **generateModel.m**: This function generates the model for the dynamic skin simulation, considering multiple conditions based on different letters (C, D, Q) and hardness levels (Soft, Medium, Hard). For each condition, it initialises parameters (such as spring constants, damping coefficients, and boundary nodes), computes the stiffness and damping matrices, and simulates the system's response to a Gaussian force profile. The simulation results (displacements and time steps) are stored, and the model response is extracted and reshaped into a 16x16 grid, representing the force-sensing data. The function saves both unnormalised and normalised model data for further analysis or visualisation, and it also prepares data for animation of the system's response over time.
- **generateModelForSpecificCondition.m**: Simulates the dynamic skin response for a specific condition, where the letter "C" is used at the medium hardness level. It initialises parameters (such as spring constants, damping coefficients, and boundary nodes), computes the stiffness and damping matrices, and simulates the system's response to a Gaussian force profile. The displacement data is extracted and reshaped into a 16x16 grid. The function saves the full force response data (z-displacement over time) to a .mat file for further analysis.
- **LetterStimulus.m**: Applies a force to the boundary nodes of the dynamic skin model based on the provided input force. It initialises the force vector for all nodes and then sets the force values for the selected boundary nodes along the z-axis. The function identifies the correct force indices corresponding to the z-component for each boundary node and applies the input force to those indices. It also includes debugging outputs to display the selected nodes, force indices, and applied forces.
- **MassSpringDamper.m**: Computes the time derivative of the state vector for the mass-spring-damper system, representing the rates of change of positions and velocities. It constructs a system of equations based on the system's mass, stiffness, and damping matrices, and solves for the state derivative at the given timestep. The state vector x is updated using the calculated accelerations and forces, with FxDyy representing the external forces applied and tFx being the corresponding time vector for those forces. The matrix A models the system's dynamics, combining position-velocity relationships, while matrix b accounts for the mass-influenced accelerations due to applied forces. The result v provides the rates of change of positions and velocities at the current timestep. This function was created by the original authors of the referenced model and was not written as part of this project.
- **MeshTriangles.m**: Generates a triangular mesh structure representing a 3-layer pyramid for the dynamic skin model. The function creates the first, second, and third layers of triangles and nodes by calculating the coordinates of each node and defining the connectivity between them. It assigns node positions in the x and y directions, then sets the z-position for each layer to simulate a pyramid-like structure with different layers offset from one another. The function then connects nodes between layers to form triangular elements. The mesh is scaled based on the provided mesh size and mass displacement, and the resulting triangular connectivity is stored in the t variable. The final mesh consists of nodes and triangles in three layers, with the appropriate z-positions defined for each layer. This function was created by the original authors of the referenced model and was not written as part of this project.
- **modelClassification.m**: Performs classification on noisy model response data using a Support Vector Machine (SVM). The function iterates over rows and trials of the noisy data, extracting the feature vector corresponding to the timestep with the highest average force-sensing response across all 256 features. It then splits the data into training and testing sets and standardises it. The SVM classifier is trained using the fitcecoc function, and predictions are made on the test set. The classification accuracy and confusion matrix are calculated and displayed.
- **modelHeatmap.m**: Generates a heatmap for the given FSR data from the first trial. The function reshapes the data into a 16x16 matrix, normalises the values to the range [0, 1], and then plots the heatmap. The title of the figure indicates the letter and hardness level associated with the data.
- **modelHeatmapTemporal.m**: Generates a series of heatmaps for the FSR data across specified time points. The function loops through the given time indices, extracts the corresponding trial data, reshapes it into a 16x16 matrix, and normalises it to the range [0, 1]. The titles of the figures indicates the letter and hardness level associated with the data and the specified timestep.
- **plotAnimation.m**: Creates an animation that visualises the dynamic movements of a multi-layered skin model based on simulated data. The function computes the displacement and distance for each node across different layers (Layer-1, Layer-2, Layer-3) at each time step, and then plots the deformation for each layer in 3D. The results are displayed using surface plots with a color gradient based on the displacement. The animation's time steps are controlled by the ts array. This function was created by the original authors of the referenced model and was not written as part of this project.
- **ShearForce.m**: Calculates the shear force between pairs of masses connected by springs in a multi-layered system. The function computes the displacement of each mass from its equilibrium position at each time step. It calculates the force between each pair of masses (spring) using the difference between the current position and the equilibrium position, and then determines the shear force by subtracting the forces from each mass. The resulting shear forces are returned for each spring over the time steps. This function was created by the original authors of the referenced model and was not written as part of this project.
- **SpringVals.m**: Calculates the stiffness (valK) and damping (valC) values for springs in a multi-layered system. The function identifies unique springs between nodes in the system, removes duplicate springs (e.g., [a,b] and [b,a]), and assigns stiffness and damping values based on the layer the spring belongs to. The layers are determined by the node indices and are categorised into three layers (L1, L2, L3). The resulting matrices valK and valC store the spring indices with their corresponding stiffness and damping coefficients. This function was created by the original authors of the referenced model and was not written as part of this project.
- **stiffnessMatrix.m**: Computes the stiffness (K) and damping (D) matrices for the dynamic skin model based on the spring connections between masses. The function iterates over all triangles, calculates the spring stiffness and damping coefficients, and assembles the global stiffness and damping matrices by applying a finite element method. The stiffness and damping values for each triangle are determined based on the distance and direction between the connected masses, with Kronecker products used to compute the element stiffness and damping matrices. The resulting K and D matrices represent the overall system's stiffness and damping properties. This function was created by the original authors of the referenced model and was not written as part of this project.

## Setup Instructions

1. Download or clone this repository.
2. Ensure MATLAB is installed and that you have the necessary toolboxes:
   - Statistics and Machine Learning Toolbox (for classification models).
3. Open and run the **main_simulation.m** script with the flags activated that correspond to the desired functions.

## Referneces
[1] U. B. Rongala, A. Seyfarth, V. Hayward and H. Jörntell, “The Import of Skin Tissue Dynamics in Tactile Sensing,” Cell Reports Physical Science, vol. 5, no. 5, 2024. 
[2] P. Uttayopas, X. Cheng, J. Eden and E. Burdet, “Object Recognition Using Mechanical Impact, Viscoelasticity, and Surface Friction During Interaction,” IEEE Transactions on Haptics, vol. 16, no. 2, pp. 251-260, 2023. 
